nvm 是对node版本的管理
nvm install 版本号
下载对应版本的nodejs
防止版本与开发的项目的版本不兼容的时候程序无法运行
在安装之后需要配置环境变量
使用 nvm -v来查看nvm的版本
使用nvm list 来查看本机上面安装的不同的nodejs的版本
nvm use 版本号 ---- 来使用对应的版本
nvm alias default 版本号  设置nodejs的默认版本号
-------------------------------------------------


npm install  包名@lastest (最新版本的包)
npm install  包名@1.1.2 (指定版本的包)
npm install 包名@">=0.1.1 <0.2.2" (下载0.1.1到0.2.0之间版本的包)

npm update [包名] (更新包)
npm outdated    查看包的版本





服务器的配置
使用第三方插件
npm install express --save(运行依赖)



npm 是服务端包的管理

(客户端包的管理) bower 
npm install bower -g 安装bower


bower init 
创建隐藏文件
null>.bowerrc

下载的前端包就存在components文件夹中
{
    "directory": "./components"
}

ajax传送数据给后端的时候

    get --使用router方式
        前端：url = "/a/"+data 
        后端：url = "a/:data";
        var getdata = request.params.data;
    post --使用body方式（第三方插件）  
        npm install body-parser  --save
        body-parser 专门处理参数的
        注:app为server对象实例
    app.use(bodyparser.json());//对数据进行json格式的处理
    app.use(bodyparser.urlencoded({ extended: false }));//对数据进行加密处理
    request.body来获取前端传入的数据(只能用于post请求中，反之无法收到数据);

    querystring解析字符串



Buffer(缓冲区)
            -Buffer的结构和数组很像，操作方法也和数组类似
            -数组不能存储二进制文件，而buffer就是专门来存储二进制数据
        Buffer.from(data);
        将data数据以二进制的形式存入在Buffer中，但是显示的时候是以16进制显示出来的（采用Unicode编码）

        创建Buffer --不推荐使用new Buffer（size）废弃
        创建一个大小为10byte的缓冲区
        var buf = Buffer.alloc(10)
        Buffer的大小一旦确定就不能更改了
        Buffer实际是对nodejs的底层的内存的直接操作
/http模块 
    引入核心模块（nodejs底层存在的模块）
        var http = require('http');
        
            创建服务器
            var server = http.createServer();
            监听request请求
            server.on('request', function (req, res) {
                // console.log('req.url');
                console.log(res.end());
            })
            创建服务器端的监听端口号
            server.listen(3000, function (err) {
                err 表示错误信息
                if (err) {
                    console.log('启动服务失败');

                    throw err;
                }
                console.log('服务启动：127.0.0.1:3000');
            })
            res.url获取请求路径

            响应数据只能是string  or Buffer
            res.end('sss')

    req.socket.remoteAddress 拿到客户端IP 
    req.socket.remotePort 拿到客户端口号
    IP 用来定位计算机的
    Port 用来定位具体的应用程序
    所有需要联网通信的应用程序都要占用一个端口号
    端口号：0~65536



Node 为js提供了很多服务器级别的API，这些API绝大多数都被包装大了一个具名的核心模块中了
    例如 文件操作的fs核心模块 http服务构建的http模块path路径操作模块，os操作系统信息模块。。。。
    在加载用户自己编写的模块的时候一定要写上./，负责系统会将其模块当做具名核心模块，没有的时候就会出报错
    加载用户自己写的模块的时候，后缀名是可以省略的
    文件作用域--模块作用域 不会污染全局，在模块内定义的代码，使用exports来暴露出去
    
module.export和export的区别
    export是module.export的引用
        export -->module.export
        当暴露数据的时候export只能通过"."的方式
        如果要暴露对象出去的话
        通过module.export,
        例如：module.export = {name：'aaa'}
        这样使得export也指向{name:'aaa'}

os用来获取机器信息的
    os.cpus获取当前操作系统的cpus信息
    os.totalmem 获取操作系统的内存大小

path ：用来操作路径的
    用来获取路径的扩展名部分
        path.extname('123.txt');

Conten-type：用来告知浏览器服务端给您发送的数据类型
    普通文本
        Content-type:text/plain
    带有一定格式的文本
        Content-type:text/html

2019.5.7  掉入的坑
    http创建的服务器不能通过服务器，使得客户端获取模块（客户端不能加载模块）;
    例如 jquery 

    阐述更改：
    		 当服务器在获取fs读取到的页面的时候，遇到script img link(href) video audio 等加载静态资源的标签的时候，客户端会针对这些资源发出请求，服务器不能获取到其资源（找不到请求路径）,一直处于等待状态，
    解决办法：	
    		将这些加载的静态资源统一放在一个例如public的目录下面，针对这个目录进行处理，进行资源的获取。把请求路当做文件路径来处理。

	注意：
		在服务器中，文件中的路径就不要去写相对路径了。
		因为这个时候素所有的资源都是通过url标识来获取到的
		例如我们开放了/public/目录
		所以这里请求路径都写成：/public/xxx
		在这里就是url根路径的意思
		浏览器在真正发请求的时候会最后把http://127.0.0.1:3000拼上
		


模板引擎（客户端、服务端）都可以用
    npm install art-template 
        模板引擎不-关心你的字符串的内容，只关心自己能认识的模板标记语法 {{}} 语法被称之为mustache语法 八字胡啊
        art-template不仅可以在浏览器中使用，也可以在node使用，
        npm 下载的包在node_module文件夹中，并且不要改，也不支持改，
    在node中使用art-template模板引擎
    模板引擎最早就是诞生于服务器领域的，后来才发展到了前端

        1.安装npm install art-template
        2.在需要使用的文件模块中加载 art-template
        var template = require('art-template');
            注:在浏览器中使用的时候直接通过script标签引入即可
        3. 查文档，使用模板引擎的API
----------------------服务端使用art-template-------------------------
        template.render('模板字符串',替换对象);
        var tplstr = `
            hello {{name}}
            I am {{age}} years old,
            I am {{sex}}
        `
       var res =  template.render(tplstr,{
            name:"Jack",
            age:20,
            sex:'male',
        })    
        console.log(res);
                运行结果：   hello Jack
                            I am 20 years old,
                            I am male
---------------------浏览器中使用art-template-------------------------
        <script type = "text/template" id= 'tpl' >
             hello {{name}}
            I am {{age}} years old,
            I am {{sex}}
            My hobbies have {{each hobbies}} {{$value}} {{/each}}
        </script>
        //进行循环
        {{each hobbies}} {{$value}} {{/each}}
        <script>
            var res = template('tpl',{
                     name:"Jack",
                    age:20,
                    sex:'male',
                    hobbies:['aaa','bbb','ccc']                    
            })
            console.log(res);
                运行结果：   hello Jack
                            I am 20 years old,
                            I am male      
        </script>
服务端和客户端渲染的区别
	客户端渲染不利于SEO搜索引擎的优化
	服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的
	所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的
	而是两者结合来做的
	例如京东的商品列表就采用的是服务端渲染目的为了SEO搜索引擎的优化
	而它的商品评论列表为用户体验，而且也不需要SEO优化，所以采用的是客户端渲染。

fs.readdir('路径',function(err,files){})

url模块 --对路劲进行解析

url.parse('http:127.0.0.1:3000/public?name=Jack&age=20');
    
    Url {
      protocol: 'http:',
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: '?name=Jack&age=20',
      query: 'name=Jack&age=20',
      pathname: '127.0.0.1:3000/public',
      path: '127.0.0.1:3000/public?name=Jack&age=20',
      href: 'http:127.0.0.1:3000/public?name=Jack&age=20'
    }

    url.parse('http:127.0.0.1:3000/public?name=Jack&age=20',true);
    Url {
          protocol: 'http:',
          slashes: null,
          auth: null,
          host: null,
          port: null,
          hostname: null,
          hash: null,
          search: '?name=Jack&age=20',
          query: [Object: null prototype] { name: 'Jack', age: '20' },
          pathname: '127.0.0.1:3000/public',
          path: '127.0.0.1:3000/public?name=Jack&age=20',
          href: 'http:127.0.0.1:3000/public?name=Jack&age=20'
      }
    使用 url.parse('路径名')，将路径转成对象，;
    使用url.parse('路径名'，true，表示直接将查询字符串转为一个对象，通过query属性来进行获取，
    使用pathname单独获取不包括查询字符串的路径部分（该路径不包括?之后的部分）


    通过服务器进行重定向
        1.状态码的设置：302临时重定向
            res.statusCode
        2.在响应头中通过Location告诉客户往哪儿重定向
           setHeader('Location','http://127.0.0.1:3000');
    301 永久重定向 浏览器会记住的
        a.com b.com
        a 浏览器不会请求a 了
        直接去调到b上
    302临时重定向 浏览器不记忆
        a.com b.com 
        a.com还会请求a 
        a告诉浏览器你往b

    模块系统
        核心模块
        第三方模块
        自己的模块
        加载规则加载机制
        循环加载
npm
package.json
Express
    +第三方web开发框架
    +高度封装了http模块
    更加专注于业务，而非底层细节
    +知其所有然
增删改查
    +使用文件来保存数据(锻炼异步编码)
MongDB（对象性数据库）
    所有方法都封装好了

什么是模块化
    如果一套平台支持
        1.文件作用域
        2.通行规则
            2.1 加载require()
            2.2 导出
CommonJS模块规范
在Node中的js还有一个很重要的概念，模块系统，
    模块作用域
    使用require方法用来加载模块
    使用exports接口对象用来导出模块中的成员
加载require
    两个作用：
        执行被加载模块中的代码
        得到被加载模块中的exports 导出接口对象
6.2.2 导出exports 
    Node 中的模块作用域 默认文件中所有的成员只在当前文件模块有效
    对于希望可以被其他模块访问的成员，我们就需要把这些公开的成员都挂在到exports接口对象中就可以了
    导出多个成员吧（必须在对象中）
    导出单个成员(拿到的就是、函数、字符串)，
    module.exports = hello；
    module.exports = function(){};

require()优先从缓存中加载
    main.js
        require('./a');
    a.js
        console.log('a.js被加载了');
        require('./b.js');
    b.js
        console.log('./b.js被加载了');
    ------- 
            a.js被加载了
            b.js被加载了
    ------  
    加载a.js的时候，在a.js中也加载了b.js，
    当你在加载回到main.js中再次加载b.js的时候直接，
    从缓存中读取，不需要再次加载，提高效率 ，
    可以再各个模块中拿到加载模块的对象
    require('模块标识')
        核心模块
        第三方模块
        自己写的模块
        如果是非路径形式的模块标识
        路径形式模块：
            ./
            ../
            /xx/x 几乎不用
            首位的/在这里标识的是当前文件夹模块所属磁盘根路径
核心模块也是文件，
    核心模块已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了
第三方模块
    凡是第三方模块都必须通过npm来下载
    使用的时候就可以通过require('包名')的方式进行加载可以使用，
    不可能有任何一个第三方包和核心模块的名字是一样的，
    既不是核心模块，也不是路径形式的模块
    var template = art-template

   

模块查找机制
    优先从模块中查找
    核心模块
    路径模块
    第三方模块

         先找到文件夹node_modules目录

        然后找node_modules/art-template
        node_modules/art-template/package.json文件
        node_modules/art_template/package.json文件
          node_modules/art_template/package.json文件中的main属性
        如果package.json问价不存在或者main指定的入口模块也是没有

        那node会自动找该目录下面的index.js
        也就是说index.js回作为一个默认被选项

        如果以上偶任何一个条件不成立的话，则会进入上一级目录中的node_modules目录查找，如果上一级还没有，则继续上上一级查找
        ....
        如果知道当前磁盘根目录还是没有找到，最后报错
            can not find modules  xxx
-------express的使用-----
var app = express();
    
    自动加载www下面的文件
    app.use(express.static(path.join(__dirname,'www')));


    // 所有文件，也可以什么都不写
    app.use("*", function (req, res) {
    
    res.status(200).sendFile(path.join(__dirname, 'www', '404.html'));
});

    把public目录开放出去，以public开头读取其中的文件

    app.use('/public/',express.static('./public/'))
    ****app.use('/public/',express.static('public'))
        访问：127.0.0.1:3000/publi/c....
    当省略第一个参数的时候，则可以通过省略 /public的方式来访问
    app.use(express.static('/public'));
        访问:127.0.0.1:3000/....
        给public 起别名
    app.use('/abc/dd/',express.static('./public/'));
        访问方式：127.0.0.1:3000/abc/dd/...
    -----------
    使用app.use('/about',function(req,res){
    直接获取about后边的请求参数
    例如：127.0.0.1:3000/about?name=Jack&age=20
             console.log(req.query())
             {name:"Jack",age:20}
        })；
        express中使用art-template模板引擎需要进行相应配置）
在express中配置art-template

    安装   npm install --save art-template
          npm install --save express-art-template

配置使用art-template模板引擎
    第一个参数，表示，当渲染以 .art结尾的文件的时候，使用art-template模板引擎
    express-art-template是专门用来在Express中把art-template整合到express中的
    虽然外面这里不需要记载art-template但是也必须安装
    原因就在于express-art-template依赖了art-template

    Express为Response相应对象提供了一个方法：render
    render方法默认是不可以使用，但是如果配置了模板引擎就可以使用了
    res.render('html模板名'，{模板数据})；
    第一个参数不能写路径，默认会去项目中的views目录查找该模板文
    也就是说Express有个约定，开发人员把所有的视图文件都放在views目录中



.art为官网定义的文件后缀名
app.engine('art',require(express-art-template))

app.get('/',function(req,res){
    res.render('404.art');
})
例如我们在使用html..等文件的时候，我们可以把engine中的art改为html..等后缀名


app.get('/admin/index.html',requrie(express-art-template));
 
app.set('views',render函数的默认路径)；第一个views默认的，第二个修改后的路径目录名

以前重定向：res.statusCode = 302;
           res.setHeader('Location','/');

现在： res.redirect('/');








            crud（增删改查）
修改完代码自动重启
    使用一个第三方命名航工具，nodemon来帮我们解决拼房修改怠慢重启服务器问题
    nodemon 是一个基于Nodex.js开发的第三方命令工具，我们使用的时候需要独立安装 
    npm install --global nodemon

    查看版本
        nodemon --version

    安装之前
     
    node app.js
    
    安装之后
     
    nodemon app.js
       
        只是通过nodemon app.js启动的服务，则它会监视你的文件变化，当文件发生变化的时候，自动帮你重启服务器。


Mongodb安装（非关系型数据库，没有结构，key-value）

    MongoDB 启动：
        默认使用执行mongod命令，所处磁符根目录下面data\db为数据库的存储位置

        没有的话数据可无法启动成功
    MongoDB链接
        重新开启一个命令窗口，使用mongo就可以连接了

     show dbs 查看所有数据库
     db 查看当前使用的数据库
     use 使用数据库

     db.student.insetOne({"name":"Jack"});

        显示当前数据库的所有集合

     show collections
        查询当前student中的的所有数据
     db.student.find();


     第三方包Mongoose来操作MongoDB数据库

npm install mysql --save

    var mysql = require('mysql');

    创建连接

    var connection  = mysql.createConnection({
        host:"locahost",
        user:"root",
        password:"12345678",
        database:"my_db"
        });

    连接数据库
    connection.connect();

    connection.query('select * from user',function (error,result,fields){
        if(error){
            throw error;
        }
        cosnole.log(result);
    });
    
Promise的ReadFile()封装
    fucntion pReadFiel(filePath){
        return  new Promist(function(res,rej){
            fs.readFile(filePath,function(err,data){
                    if(err){
                        rej(err);
                    }else{
                        res(data)
                    }

            })
        })
    }
pReadFile(url)
    .then(function(data){
        
        return pReadFile(url2);
    })
    .then(function(data){
        return pReadFile(url3);
    })
    .then(function(data){
        return ....
    })

path:

    path.basename('./name/a/index.js);//index.js获取文件名包含文件名

    path.basename('./name/a/index.js','.js);//index获取文件名（不包括文件名）;
    path.extname('./name/index.js);获取文件扩展名  //.js

    path.isAbsolute(url);判断当前路径是否是聚绝对路径

    对当前路径进行解析，返回一个对象
    path.parse('/a/index.html');
            { root: '/',
            dir: '/a',
            base: 'index.js'
            ext: '.js',
            name: 'index' }
        __dirname :用来获取到模块的所属目录的绝对路径
        __filename:用来获取当前文件的绝对路径

        在node中./a.txt中的.不是相对于当前文件路径，
        是相对于执行node命令所处的终端路径
        就是说，文件操作路径中，相对于路径设计的就是相对于执行node命令所处的路径

        模块中的路径标识和文件操作中的相对路径标识不一致， 
        模块中的路径标识及时相对于当前文件模块，不受执行node命令所处路径影响



        app请求匹配方式

        use('/',function(req,res,next{});以 / 开头进行匹配
            next表示 下一次的中间件
            next是一个方法 当在调用的时候会匹配下一个满足条件的中间件

        严格请求匹配方式
        
        get('/',function(req,res){}) ;      请求方式是 / 的进行匹配
        post('/',function(req,res){}) ;

        同一个请求所经过的中间件都是同一个请求对象和响应对象;


            app.get('/ab',function(req,res,next){
                
                req.bar = "foo";
                next();
            
            }) 
    
            app.get('/ab',function(req,res,next){
            
                    console.log(req.bar);//foo
            }) 

    当调用next的时候，如果传递了参数，则直接往后找到带有，四个参数的应用程序，级别中间件，
    当发生错误的时候，我们可以调用next传递错误对象，然后就会被全局错误处理中间件匹配到并处理之。


    bcryptjs 加密

    gravatar 全国公认头像

    jsonwebtoken  生成token

        在生成token的时候在前边一定要加上:"Bearer "

        jwt-payload  得到反序列化
        koa-passport 得到token
     










        
    

        




















































        











    



















